from manim import *
class Sincos(MovingCameraScene):
    def construct(self):
        self.camera.frame.scale(0.8)
        self.border = Rectangle(width=self.camera.frame.get_width(),
                                height=self.camera.frame.get_height())
        self.add(self.border)
        title=Title("WHY").scale(0.4).shift(DOWN)
        sub_tile=MathTex("\\cos^{2}(\\theta)","+","\\sin^{2}(\\theta)","=1").set_color_by_tex_to_color_map({"cos":PINK,"sin":GREEN}).scale(0.4).next_to(title,DOWN)
        self.play(Write(title))
        self.play(Write(sub_tile))
        circ=Circle()
        line=always_redraw(lambda:Line(ORIGIN,circ.get_end()))
        self.play(Write(line))
        self.play(Create(circ))
        dot=Dot(np.array([np.cos(PI/4),np.sin(PI/4),0])).scale(0.5)
        self.play(FadeIn(dot))
        dashed_line=DashedLine(ORIGIN,dot.get_center())
        unit_label=MathTex("1").scale(0.3).next_to(dashed_line,UP,buff=0).shift(0.1*LEFT+0.3*DOWN)
        angel=Angle(line,dashed_line,radius=0.2).set_stroke(width=2)
        label=MathTex("\\theta").next_to(angel,RIGHT,buff=0).scale(0.3).shift(0.1*UP)
        sincoslabel=MathTex("(","\\cos(\\theta)",",","\\sin(\\theta)",")")\
            .scale(0.3).next_to(dot.get_center(),RIGHT,buff=0.1)\
            .set_color_by_tex("\\cos(\\theta)",BLUE)\
            .set_color_by_tex("\\sin(\\theta)",YELLOW)
        dashed_line_v=DashedLine(RIGHT*np.cos(PI/4),UP*np.cos(PI/4)+RIGHT*np.cos(PI/4))
        # self.add(dashed_line,angel,label,sincoslabel,dashed_line_v,unit_label)
        self.play(Create(dashed_line_v))
        self.play(Create(dashed_line))
        self.play(Create(sincoslabel))
        alu=VGroup(angel,label,unit_label)
        self.play(Create(alu))
        self.play(ApplyMethod(sincoslabel[1].next_to,line,DOWN,0.1))
        self.remove(sincoslabel[2],sincoslabel[0],sincoslabel[-1])
        self.play(ApplyMethod(sincoslabel[3].next_to, dashed_line_v, RIGHT, 0.1))
        tri=VMobject(color=YELLOW).set_points_as_corners([ORIGIN,RIGHT*np.cos(PI/4),UP*np.cos(PI/4)+RIGHT*np.cos(PI/4),ORIGIN]).set_stroke(width=2)
        self.play(Create(tri))
        group=VGroup(tri,angel,label,sincoslabel[1],sincoslabel[3],unit_label)
        self.play(AnimationGroup(*[FadeOut(i) for i in [circ,dashed_line_v,dashed_line,line,dot]]))
        self.play(group.animate.scale(2).move_to(ORIGIN),run_time=2)
        tri_point=tri.get_start_anchors()
        p_point=(1-np.cos(PI/4)**2)*tri_point[0]+np.cos(PI/4)**2*tri_point[2]
        p_line=DashedLine(p_point,tri_point[1]).set_stroke(width=2)
        second=Line(tri_point[0],tri_point[2])
        p_angle=RightAngle(p_line,second,quadrant=(1,-1)).scale(0.2,about_point=p_point).set_stroke(width=2)
        # self.add(p_line,p_angle)
        self.play(Create(p_line))
        self.play(Create(p_angle))
        tri2=VMobject(color=PINK).set_points_as_corners([tri_point[0],tri_point[1],p_point,tri_point[0]])
        la_c=sincoslabel[1].copy()
        cos2=MathTex("\\cos^{2}(\\theta)",color=PINK).scale(0.4).next_to((tri_point[0]+p_point)/2,UP,0.2).shift(0.3*LEFT+0.2*DOWN)
        cos2c=cos2.copy()
        self.play(Create(tri2))
        tri2_group=VGroup(la_c,tri2,p_angle.copy(),angel.copy(),label.copy()).save_state()
        self.play(tri2_group.animate.shift(1.5*DOWN+0.5*LEFT).rotate((135*DEGREES)))#.rotate((135*DEGREES)
        self.play(tri2_group[0].animate.shift(0.2*DOWN+0.2*RIGHT).rotate(-135*DEGREES))
        tri2_cirner=tri2.get_start_anchors()
        tri2_label=MathTex("A","B","C").set_color_by_tex_to_color_map({"A":RED,"B":PINK,"C":GREEN}).scale(0.4)
        tri2_label[0].next_to(tri2_cirner[0],DOWN,0.1)
        tri2_label[1].next_to(tri2_cirner[1], UP, 0.1)
        tri2_label[2].next_to(tri2_cirner[2], DOWN, 0.1)
        cos2c.next_to(tri2_group,DOWN,0.1)
        soleve_eq = MathTex("\\frac{AC}{BA}", "=", "\\cos(\\theta)").scale(0.4).next_to(tri2, RIGHT, 0.3)
        # self.add(tri2_label,soleve_eq)
        self.play(Create(tri2_label))
        self.play(Create(soleve_eq))
        copy_solv=MathTex(".\\cos(\\theta)").scale(0.4).next_to(soleve_eq[-1],RIGHT,0.1)
        self.play(ApplyMethod(soleve_eq[0][3:].move_to,copy_solv),FadeOut(soleve_eq[0][2]),run_time=2)
        self.play(ApplyMethod(soleve_eq[0][3:].become, copy_solv))
        result_eq=VGroup(soleve_eq[0][3:],soleve_eq[-1])
        cos2c1=MathTex("\\cos^{2}(\\theta)").scale(0.4).move_to(result_eq,aligned_edge=LEFT)
        self.play(Transform(result_eq,cos2c1),ApplyMethod(soleve_eq[0][0:2].shift,0.1*DOWN))
        self.play(ApplyMethod(result_eq.move_to,cos2c),FadeOut(soleve_eq[0][0:2]),run_time=2)
        self.play(ApplyMethod(tri2_group.restore),ApplyMethod(cos2c.become,cos2))
        self.remove(tri2_label,soleve_eq,result_eq,soleve_eq[1])
        sin_lin = Line(tri_point[1], tri_point[2])
        sin_lin2 = Line(tri_point[2], tri_point[0])
        sin_angle = Angle(sin_lin, sin_lin2, quadrant=(-1, 1), other_angle=True)
        sin_angle_l=MathTex("90-\\theta").scale(0.25).next_to(sin_angle,DOWN,0.1).shift(0.1*LEFT)
        self.add(sin_angle,sin_angle_l)
        tri2_s = VMobject(color=GREEN).set_points_as_corners([tri_point[1], tri_point[2], p_point, tri_point[1]])
        sin2=MathTex("\\sin^{2}(\\theta)",color=GREEN).scale(0.4).next_to((tri_point[2]+p_point)/2,UP,0.2).shift(0.3*LEFT+0.2*DOWN)
        sin2c=MathTex("\\cos^{2}(90-\\theta)",color=GREEN).scale(0.4)
        sin2c1=sin2.copy()
        sin2c2 = sin2.copy()
        self.play(Create(tri2_s))
        tri2_s_group=VGroup(tri2_s,sin_angle,sin_angle_l,sincoslabel[3]).save_state()
        self.play(tri2_s_group.animate.shift(2*DOWN).rotate((135*DEGREES)))
        self.play(ApplyMethod(tri2_s_group[2].rotate,-135 * DEGREES),ApplyMethod(tri2_s_group[-1].shift(0.2*DOWN).rotate,-135 * DEGREES))
        sin2c.next_to(tri2_s_group,DOWN,0.1).shift(0.2*RIGHT)
        sin2c1.next_to(tri2_s_group, DOWN, 0.1).shift(0.2 * RIGHT)
        tri2_cirner2 = tri2_s.get_start_anchors()
        tri2_label2 = MathTex("A", "B", "C").set_color_by_tex_to_color_map({"A": RED, "B": PINK, "C": YELLOW}).scale(0.4)
        tri2_label2[0].next_to(tri2_cirner2[0], UP, 0.1)
        tri2_label2[1].next_to(tri2_cirner2[1], DOWN, 0.1)
        tri2_label2[2].next_to(tri2_cirner2[2], DOWN, 0.1).shift(0.2*RIGHT)
        # cos2c.next_to(tri2_group, DOWN, 0.1)
        self.add(tri2_label2)
        soleve_eq_s = MathTex("\\frac{BC}{AB}", "=", "\\cos(90-\\theta)").scale(0.32).next_to(tri2_s_group, LEFT, 0.1)
        self.play(Write(soleve_eq_s),ApplyMethod(tri2_s_group.shift,0.6*RIGHT),ApplyMethod(tri2_label2.shift,0.6*RIGHT))
        self.play(ApplyMethod(soleve_eq_s[0][3:].next_to,soleve_eq_s[-1],RIGHT,0.1),FadeOut(soleve_eq_s[0][2]),ApplyMethod(soleve_eq_s[0][:2].shift,0.1*DOWN))
        sin_t=always_redraw(lambda :MathTex("\\sin(\\theta)").scale(0.4).next_to(soleve_eq_s[-1],RIGHT,0.1))
        sin_tc=MathTex("\\sin(\\theta)").scale(0.4).move_to(soleve_eq_s[-1],aligned_edge=LEFT)
        self.play(Transform(soleve_eq_s[0][3:],sin_t),run_time=2)
        self.play(Transform(soleve_eq_s[-1],sin_tc),run_time=2)
        sint_group=VGroup(soleve_eq_s[0][3:],soleve_eq_s[-1])
        sin2c2.move_to(sint_group,aligned_edge=LEFT)
        self.play(Transform(sint_group,sin2c2),run_time=2)
        self.play(ApplyMethod(sint_group.move_to,sin2c.shift(0.6*RIGHT)),run_time=2)
        # self.play(Write(sin2c.shift(0.6*RIGHT)))
        self.play(ApplyMethod(tri2_s_group.restore),ApplyMethod(sint_group.become,sin2))
        # self.play(soleve_eq_s[0].animate.shift(UP),rate_func=there_and_back)
        self.remove(tri2_label2,soleve_eq_s[1],soleve_eq_s[0])
        self.play(FadeOut(soleve_eq_s[0][0:2]))
        # self.play(ApplyMethod(cos2c.shift,DOWN),ApplyMethod(cos2c.shift,DOWN))
        new_cos=cos2c.copy()
        new_s=sint_group.copy()
        # new_s=always_redraw(lambda :new.next_to(new_cos,RIGHT,0.1))
        # self.add(new_s)
        new_t_sin=MathTex("+","\\sin^{2}(\\theta)",color=GREEN)
        self.play(ApplyMethod(new_cos.shift,2*DOWN))
        new_t_sin.scale(0.4).next_to(new_cos,RIGHT,0)
        self.play(Transform(new_s,new_t_sin),run_time=2)
        # self.play(ApplyMethod(new_s.become,new_t_sin))
        equal_to1=MathTex("=1").scale(0.4).next_to(new_s,RIGHT,0.1)
        copy1=unit_label.copy()
        self.play(Transform(copy1,equal_to1),run_time=2)
        final_group=VGroup(equal_to1,new_s,new_cos)
        sourr_rect=SurroundingRectangle(final_group,color=YELLOW)
        self.play(Create(sourr_rect),rate_func=there_and_back)
        self.wait()